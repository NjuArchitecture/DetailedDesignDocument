# LoadBalance 模块 #

## 词汇表 ##

| 英文| 中文 | 备注  |
| :--- | :--- | :--- |
| Tokenlization  |序列化| |
| Normalization  |标准化  |
|Front Service|前端服务| 前端是相对而言的,这里是指调用搜索服务的一方|
|Data Provider| 数据提供者 | 如爬虫|
|Query| 查询语言|内部定义的查询语言类|


## 一、概述 ##
### 承担的需求（主要秘密） ###

同一个服务在多台机器上部署,负载均衡用来解决选取哪一个服务器的问题.需要尽量挑选空闲服务器,避开忙碌或宕机的服务器.


### 可能会修改的实现（次要秘密） ###
	
* 负载均衡算法
* 服务列表的维护
* 服务的健康监测
* 不同的注册中心


### 涉及的相关质量属性 ###

* R2 服务可靠性
* R10 高峰吞吐量

### 设计概述 ###

一个服务可能调用其他多个服务,而每个服务有多台实际的服务器.所以我们采用LoadBalancerClient,下简称Client,作为各个服务的门面,发起者可以直接调用Client.每一种服务对应一个LoadBalancer对象,提供对服务列表的初始化/选择/增加/删除等操作.

对于不同的负载均衡算法,封装在LoadBalanceStrategy中.对于不同的服务列表维护方法,比如读配置中的静态服务列表,或注册中心查询到的列表,通过UpdateStrategy封装.

### 角色 ###


### 模块对外接口 ###

1. Object **execute**(Request request);

## 二、类的设计 ##

### 2.1 类图 ###

![](/assets/sbin/LoadBalanceClass.png)

### 2.2 类描述 ###
#### LoadBalancerClient类 ####
##### 类职责 #####

本类是LoadBalancer模块的门面,提供execute方法来发起服务调用


##### 类方法 #####
* public Object execute(Request request): 
	* 职责：发起一次请求
	* 前置条件：配置正确,服务初始化成功
	* 后置条件：完成PersistenceService类的初始化

---

#### TempSave类 ####
##### 类职责 #####
本类的职责是暂时存储DataProvider传过来的大量数据，并以流的方式提供商品的数据。

##### 类方法 #####
* public void addCommodity(List\<Commodity\>)
	* 职责：增加商品信息到临时存储空间中
	* 前置条件：类初始化完成
	* 后置条件：将商品信息转化成流式暂时存储

* public void getCommodity():Stream\<Commodity\>
	* 职责：返回缓存池里未持久化的信息
	* 前置条件：类初始化完成
	* 后置条件：返回未持久化的商品信息

---

#### PreProcessing类 ####
##### 类职责 #####
本类的职责主要是预处理Commodity，并将预处理过后的Commodity信息以流的形式返回。
可能的预处理逻辑包括增加域，修改域的信息，如将字符串时间转化为时间戳等
预处理的逻辑可能变化，因此采用策略模式，将具体的预处理逻辑放在PreProcessStrategy中

##### 类方法 #####
* public void getCommodity():Stream\<Commodity\>
	* 职责：返回预处理后的信息
	* 前置条件：从TempSave类处获取数据
	* 后置条件：返回预处理后的商品信息流

* private void process()
	* 职责：预处理信息，调用PreProcessStrategy实现
	* 前置条件：预处理策略已设置
	* 后置条件：完成预处理

---




#### CacheMessageHolder类 ####
##### 类职责 #####
存储高频搜索的关键字及其商品信息的Map，定期清理很长时间未被访问的关键字所对应的商品信息

##### 类方法 #####
* public isInCache(Key):boolean
	* 职责：判断关键字是否位于缓存中
	* 前置条件：关键词经过处理
	* 后置条件：返回关键词是否位于Cache中
* public Collection\<Commodity\> getCommodityFromCache(Set\<Key\>)
	* 职责：从缓存中读取关键字所对应的商品信息
	* 前置条件：关键字的相关结果位于缓存中
	* 后置条件：返回关键字对应的商品信息


---

## 三、重要协作 ##
### 顺序图 ###
####  存储模块顺序图 ####


---

### 状态图 ###
####  存储模块状态图 ####

---
#### 搜索模块状态图 ####

## 四、设计模式应用 ##

### 策略模式 ###

>策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。-- wikipedia

在Search Engine模块中，由于外界因素的不确定性，搜索的具体实现细节可能会不断地变化，为了符合开闭原则，应当避免在修改搜索策略时破坏已有代码的封装，为此，SearchEngine模块中大量使用了策略模式，将易于变化的部分独立出来，声明一个策略接口，含有算法的接口，并将实现存放于具体的策略实现子类，实现了将算法的具体实现推迟到了运行时的绑定，使得修改策略仅需要实现一个新的策略实现子类即可，并调用setStrategy()方法修改策略即可，从而保证了高内聚和低耦合


